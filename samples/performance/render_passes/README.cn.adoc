////
- Copyright (c) 2019-2025, Arm Limited and Contributors
-
- SPDX-License-Identifier: Apache-2.0
-
- Licensed under the Apache License, Version 2.0 the "License";
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-
////
= 正确使用渲染通道附件（Appropriate use of render pass attachments）

ifdef::site-gen-antora[]
TIP: 本示例源码位于 https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/performance/render_passes[Khronos Vulkan Samples GitHub 仓库]。
endif::[]

== 概览

Vulkan 渲染通道（render pass）用附件描述输入与输出的渲染目标。本示例演示“加载与存储附件”对移动端性能的影响。

创建渲染通道时可指定若干颜色附件与一个深度/模板附件。每个附件由 `VkAttachmentDescription` 描述，包含 `loadOp`（加载操作）与 `storeOp`（存储操作）。示例允许在运行时选择不同组合。

== 颜色附件 load 操作

示例用一个颜色附件（交换链图像）渲染场景。若通道开始时不需要读取其内容，应使用 `LOAD_OP_DONT_CARE` 以避免加载开销。但若未覆盖整个帧缓冲，未绘制区域会显示随机色或前帧像素；此时应使用 `LOAD_OP_CLEAR` 并设置清屏颜色。`LOAD_OP_LOAD` 在此是错误选择：既不使用其内容又增加带宽。

观测示例中 `LOAD_OP_LOAD` vs `LOAD_OP_CLEAR` 的外部读带宽差约 600MiB/s；未压缩附件可用公式估算带宽：`width * height * bpp/8 * FPS`（压缩图像的节省会更低，见 AFBC 示例）。

== 深度附件 store 操作

若后续通道需要深度，需 `STORE_OP_STORE`；否则可用 `STORE_OP_DONT_CARE`。示例无第二通道，因此无需存储深度。深度图可用 `LAZILY_ALLOCATED` 分配：仅当需要写回（`STORE_OP_STORE`）时，平铺 GPU 才实际分配物理存储。示例显示 `STORE_OP_STORE`→`STORE_OP_DONT_CARE` 可将写事务约减少 555 MiB/s。

Streamline 进一步显示：约 10.4s 处，`LOAD`→`CLEAR` 的读带宽降低明显；约 18.1s 处，`STORE`→`DONT_CARE` 的写带宽陡降。

== 关于 `vkCmdClear*`

不必用 `vkCmdClear*` 清附件：`LOAD_OP_CLEAR` 即可且更高效。某些移动设备上 `vkCmdClear*` 会生成“逐片段清除着色器”，增加额外片段周期。尽管 `vkCmdClearAttachments` 可清通道内的局部区域（LOAD_OP 不覆盖此用例），但默认应优先用 `loadOp` 实现全屏清。

== 深度图像用法

除设置 `DEPTH_STENCIL_ATTACHMENT` 外，可设置 `TRANSIENT_ATTACHMENT` 表示深度图仅在单个通道存活；配合 `LAZILY_ALLOCATED` 可无需物理存储。

== 渲染区域粒度

开始渲染通道时给定的 `renderArea` 应检查 `vkGetRenderAreaGranularity` 是否最优（offset/extent 与粒度的关系）。非最优区域可能负面影响性能。

== 最佳实践

- 建议：
  - 在通道开始用 `LOAD_OP_CLEAR/DONT_CARE` 清或作废每个附件；确保颜色/深度/模板写掩码未屏蔽清除；
  - 未作为输入的附件使用 `LOAD_OP_DONT_CARE`；
  - 仅在单通道存活的附件设置 `TRANSIENT_ATTACHMENT` + `LAZILY_ALLOCATED`，并在通道结束 `storeOp = DONT_CARE`；
  - 若只渲染子区域，使用剪裁框（scissor）限制清除与渲染区域；
- 避免：
  - 对通道内将被使用的图像调用 `vkCmdClearColorImage/DepthStencilImage`（将清移入 `loadOp`）；
  - 不必要地在通道内用 `vkCmdClearAttachments`；
  - 用着色器手动写常量色清屏；
  - 未依赖初始内容时使用 `LOAD_OP_LOAD`；
  - 为未在本通道使用的附件设置 loadOp/storeOp（会触发多余的往返 tile 内存）；
  - 为低分辨率帧做 `vkCmdBlitImage` 上采样并在其上方以 `LOAD_OP_LOAD` 渲染 UI/HUD（造成不必要的往返内存）；
- 影响：
  - 渲染通道配置不当会导致片段性能下降与带宽上升（需在开始读取未清附件、结束写回未作废附件）；
- 调试：
  - 检查 `VkAttachmentDescription`、`vkCreateRenderPass` 与 `vkCmdClear*` 等调用的使用是否合理。
