////
 * Copyright (c) 2024, Huawei Technologies Co., Ltd.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 the "License";
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
////
= 使用 Vulkan 1.3 特性的 Hello Triangle

ifdef::site-gen-antora[]
TIP: 本示例源码位于 https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/api/hello_triangle_1_3[Khronos Vulkan Samples GitHub 仓库]。
endif::[]

本示例展示如何使用 Vulkan 1.3 核心特性渲染一个简单的三角形。相较于传统的 “Hello Triangle”，本示例引入并使用了以下特性：

- 动态渲染（Dynamic Rendering）
- Synchronization2（同步 2）
- 扩展动态状态（Extended Dynamic State）
- 顶点缓冲（Vertex Buffers）

## 概览

该示例将一个带颜色的三角形渲染到屏幕上，并演示如何：

- 在初始化阶段启用 Vulkan 1.3 的相关特性；
- 使用动态渲染以简化渲染管线；
- 采用 Synchronization2 API 进行更清晰的同步；
- 利用扩展动态状态减少管线复杂度；
- 使用顶点缓冲管理顶点数据（替代在着色器中硬编码顶点）。

## 关键特性

### 1. 动态渲染（Dynamic Rendering）

动态渲染是 Vulkan 1.3 引入的特性，可在不预先定义渲染通道（render pass）与帧缓冲（framebuffer）的情况下进行渲染。它允许你在记录命令缓冲时直接指定渲染状态，从而简化渲染流程。

示例中的用法：

- 不再创建 `VkRenderPass` 或 `VkFramebuffer` 对象；
- 使用 `vkCmdBeginRendering()` 与 `vkCmdEndRendering()` 动态开启/结束渲染；
- 在创建图形管线时，通过 `VkPipelineRenderingCreateInfo` 指定渲染细节。

优势：

- 减少与渲染通道和帧缓冲有关的样板代码；
- 提升灵活性，可在无需重建渲染通道的情况下切换不同附件。

### 2. Synchronization2（同步 2）

Synchronization2 是 Vulkan 1.3 引入的改进版同步 API，提供更细粒度的控制并简化同步操作。

示例中的用法：

- 使用 `vkCmdPipelineBarrier2()` 替代旧的 `vkCmdPipelineBarrier()`；
- 结合 `VkDependencyInfo` 与 `VkImageMemoryBarrier2` 精确描述内存依赖与图像布局转换。

示例代码：

```cpp
VkImageMemoryBarrier2 image_barrier = {
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
    // ... 其他成员 ...
};

VkDependencyInfo dependency_info = {
    .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
    .imageMemoryBarrierCount = 1,
    .pImageMemoryBarriers = &image_barrier,
};

vkCmdPipelineBarrier2(cmd, &dependency_info);
```

优势：

- 更具表达力与灵活性的同步方式；
- 降低同步出错的可能性；
- 简化流水线阶段与访问掩码的指定。

### 3. 扩展动态状态（Extended Dynamic State）

扩展动态状态允许在记录命令缓冲时再设置更多的管线状态，而非在管线创建时固定，减少需要创建的管线数量。

示例中的用法：

- 启用 `VK_DYNAMIC_STATE_CULL_MODE`、`VK_DYNAMIC_STATE_FRONT_FACE`、`VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY` 等动态状态；
- 调用 `vkCmdSetCullMode()`、`vkCmdSetFrontFace()`、`vkCmdSetPrimitiveTopology()` 动态设置相关状态。

示例代码：

```cpp
vkCmdSetCullMode(cmd, VK_CULL_MODE_NONE);
vkCmdSetFrontFace(cmd, VK_FRONT_FACE_CLOCKWISE);
vkCmdSetPrimitiveTopology(cmd, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST);
```

优势：

- 无需为不同状态组合创建多条管线；
- 允许在不重建管线的情况下灵活切换状态。

### 4. 顶点缓冲（Vertex Buffers）

与最初版本在着色器中硬编码顶点不同，本示例通过顶点缓冲存储顶点数据。

示例中的用法：

- 顶点结构体：

```cpp
struct Vertex {
    glm::vec2 position;
    glm::vec3 color;
};
```

- 将顶点数据写入缓冲：

```cpp
std::vector<Vertex> vertices = {
    {{0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}}, // 红色顶点
    // ... 其他顶点 ...
};
```

- 创建缓冲与分配内存：

```cpp
VkBufferCreateInfo buffer_info = { /* ... */ };
vkCreateBuffer(device, &buffer_info, nullptr, &vertex_buffer);

VkMemoryAllocateInfo alloc_info = { /* ... */ };
vkAllocateMemory(device, &alloc_info, nullptr, &vertex_buffer_memory);
```

- 绑定顶点缓冲：

```cpp
vkCmdBindVertexBuffers(cmd, 0, 1, &vertex_buffer, &offset);
```

优势：

- 灵活：更易修改顶点数据而无需改动着色器；
- 性能：更高效的内存使用潜力；
- 可扩展：便于渲染更复杂的几何体。

## 工作流程

1. 初始化：
   - 创建实例：使用 Vulkan 1.3 API 版本与所需扩展初始化实例；
   - 选择设备：选择支持 Vulkan 1.3 与所需特性的物理设备；
   - 创建设备：启用动态渲染、Synchronization2 与扩展动态状态等特性；
   - 创建表面与交换链：为呈现图像设置窗口表面与交换链；

2. 顶点缓冲设置：
   - 定义顶点（位置与颜色）；
   - 创建缓冲并分配内存，将顶点数据映射写入；

3. 管线设置：
   - 加载并创建着色器模块；
   - 创建管线布局（此示例无描述符）；
   - 指定需要的动态状态；
   - 创建图形管线（包含动态渲染信息与动态状态）；

4. 渲染循环：
   - 获取下一个交换链图像；
   - 记录命令缓冲：
     - `vkCmdBeginRendering()` 开始动态渲染；
     - 动态设置视口、裁剪、背面剔除方式、正面朝向与图元拓扑；
     - 绑定图形管线与顶点缓冲；
     - 发出绘制调用；
     - `vkCmdEndRendering()` 结束渲染；
     - 使用 `vkCmdPipelineBarrier2()` 进行呈现前的图像布局转换；
   - 提交命令到图形队列；
   - 呈现图像到屏幕；

5. 资源清理：
   - 应用退出时销毁管线、缓冲、交换链图像等 Vulkan 资源。

## 依赖与要求

- Vulkan SDK 1.3 或更新版本；
- 硬件需支持 Vulkan 1.3（包括动态渲染、Synchronization2、扩展动态状态等）；
- GLM 库（用于向量/矩阵运算）；
- 着色器编译器（GLSL 着色器在运行时编译）。