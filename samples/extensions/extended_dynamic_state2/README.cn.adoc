////
- Copyright (c) 2023-2025, Mobica Limited
-
- SPDX-License-Identifier: Apache-2.0
-
- Licensed under the Apache License, Version 2.0 the "License";
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-
////
= 扩展动态状态 2（Extended Dynamic State 2）

ifdef::site-gen-antora[]
TIP: 本示例的源码位于 https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/extensions/extended_dynamic_state2[Khronos Vulkan Samples GitHub 仓库]。
endif::[]

image::./images/extended_dynamic_state2_screenshot.png[Sample]

== 概述

本示例展示如何使用 `VK_EXT_extended_dynamic_state2` 扩展。当存在一组特定但不同的参数时，该扩展可避免为每种情况创建多条管线。

该扩展改变了“深度偏移（Depth Bias）”“图元重启（Primitive Restart）”“光栅化丢弃（Rasterizer Discard）”以及“曲面细分控制点（Patch Control Points）”等状态的管理方式。过去需要在管线创建时静态描述；有了该扩展，开发者可以在每次绘制前通过函数动态修改这些参数。

下面对常见的静态实现与使用动态状态（并结合 `vkCmdSetPrimitiveTopologyEXT`）的实现进行对比：

|===
| 静态/非动态 | Dynamic State 2

| dynamic_state = {}
| dynamic_state = {VK_DYNAMIC_STATE_VIEWPORT, + VK_DYNAMIC_STATE_SCISSOR, + VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT, + VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT, + VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT, + VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT, + VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT}

| vkCreateGraphicsPipelines(pipeline1) + vkCreateGraphicsPipelines(pipeline2) + vkCreateGraphicsPipelines(pipeline3) + vkCreateGraphicsPipelines(pipeline4)
| vkCreateGraphicsPipelines(pipeline1) + vkCreateGraphicsPipelines(pipeline2)

| draw(model1, pipeline1) + draw(model2, pipeline2) + draw(model3, pipeline3) + draw(model4, pipeline4)
| vkCmdSetPrimitiveRestartEnableEXT(commandBuffer1, primitiveBoolParam) + vkCmdSetDepthBiasEnableEXT(commandBuffer1, depthBiasBoolParam) + vkCmdSetRasterizerDiscardEnableEXT(commandBuffer1, rasterizerBoolParam) + vkCmdSetPrimitiveTopologyEXT(commandBuffer1, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST) + draw(model1, pipeline1) + vkCmdSetPrimitiveTopologyEXT(commandBuffer2, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP) + vkCmdSetPrimitiveRestartEnableEXT(commandBuffer2, primitiveBoolParam) + draw(model2, pipeline1) + vkCmdSetDepthBiasEnableEXT(commandBuffer3, depthBiasBoolParam) + vkCmdSetPrimitiveRestartEnableEXT(commandBuffer3, primitiveBoolParam) + draw(model3, pipeline1) + vkCmdSetPatchControlPointsEXT(commandBuffer4, patchControlPoints) + draw(model4, pipeline2)
|===

更多细节见下文。

== 管线（Pipelines）

过去，开发者需要为深度偏移、图元重启、光栅化丢弃、曲面细分控制点等不同参数组合创建多条管线，示例如下（静态/非动态的管线创建）：

[,C++]
----
...
/* 第一条管线的创建 */
VkPipelineInputAssemblyStateCreateInfo input_assembly_state =
	vkb::initializers::pipeline_input_assembly_state_create_info(
	    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, /* 用于第1、2条管线 */
	    0,
	    VK_FALSE); /* primitiveRestartEnable */

VkPipelineRasterizationStateCreateInfo rasterization_state =
	vkb::initializers::pipeline_rasterization_state_create_info(
	    VK_POLYGON_MODE_FILL, /* 用于第1、2、3条管线 */
	    VK_CULL_MODE_BACK_BIT,
	    VK_FRONT_FACE_CLOCKWISE,
	    0);
rasterization_state.depthBiasConstantFactor = 1.0f;
rasterization_state.depthBiasSlopeFactor    = 1.0f;
rasterization_state.depthBiasClamp          = 0.0f;

/* 说明：为了提高精度，我们使用“反向深度缓冲”，因此保留更大的深度值 */
VkPipelineDepthStencilStateCreateInfo depth_stencil_state =
	vkb::initializers::pipeline_depth_stencil_state_create_info(
	    VK_TRUE, /* depthTestEnable */
	    VK_TRUE, /* depthWriteEnable */
	    VK_COMPARE_OP_GREATER);
...

/* 所有管线共用的 VkGraphicsPipelineCreateInfo，每次创建前按需修改参数 */
VkGraphicsPipelineCreateInfo graphics_create{VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO};
graphics_create.pInputAssemblyState = &input_assembly_state;
graphics_create.pRasterizationState = &rasterization_state;
graphics_create.pDepthStencilState  = &depth_stencil_state;
graphics_create.pTessellationState  = VK_NULL_HANDLE;
...

VK_CHECK(vkCreateGraphicsPipelines(get_device().get_handle(), pipeline_cache, 1, &graphics_create, VK_NULL_HANDLE, &pipeline1));

/* 第二条管线 */
rasterization_state.rasterizerDiscardEnable = VK_TRUE;

VK_CHECK(vkCreateGraphicsPipelines(get_device().get_handle(), pipeline_cache, 1, &graphics_create, VK_NULL_HANDLE, &pipeline2));

/* 第三条管线 */
rasterization_state.rasterizerDiscardEnable = VK_FALSE;
input_assembly_state.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
input_assembly_state.primitiveRestartEnable = VK_TRUE;

VK_CHECK(vkCreateGraphicsPipelines(get_device().get_handle(), pipeline_cache, 1, &graphics_create, VK_NULL_HANDLE, &pipeline3));

/* 第四条管线 */
VkPipelineTessellationStateCreateInfo tessellation_state = 	vkb::initializers::pipeline_tessellation_state_create_info(3);
graphics_create.layout = pipeline_layouts.tesselation;
graphics_create.pTessellationState  = &tessellation_state;
input_assembly_state.topology = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST;
input_assembly_state.primitiveRestartEnable = VK_FALSE;
rasterization_state.depthBiasEnable = VK_TRUE;
if (get_device().get_gpu().get_features().fillModeNonSolid)
{
	rasterization_state.polygonMode = VK_POLYGON_MODE_LINE; /* 线框模式 */
}

VK_CHECK(vkCreateGraphicsPipelines(get_device().get_handle(), pipeline_cache, 1, &graphics_create, VK_NULL_HANDLE, &pipeline4));
----

在上述方式下，如果开发者想更改“曲面细分控制点”的数量，则每个不同数量都需要新建一条管线。

借助 `VK_EXT_extended_dynamic_state2`，可以在绘制前分别调用 `vkCmdSetDepthBiasEnableEXT`、`vkCmdSetPrimitiveRestartEnableEXT`、`vkCmdSetRasterizerDiscardEnableEXT` 和 `vkCmdSetPatchControlPointsEXT` 来调整“深度偏移”“图元重启”“光栅化丢弃”“曲面细分控制点”等参数，从而减少需要创建的管线数量。

使用这些函数时，需在 `VkGraphicsPipelineCreateInfo` 中启用并传入对应的动态状态。

`VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT` 指定在 `VkPipelineInputAssemblyStateCreateInfo` 里的拓扑参数仅指定“拓扑类别”。具体拓扑（顺序、邻接等）必须在任何绘制命令之前通过 `vkCmdSetPrimitiveTopology` 动态设置。

[,C+]
----
VkPipelineInputAssemblyStateCreateInfo input_assembly_state =
	vkb::initializers::pipeline_input_assembly_state_create_info(
	    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
	    0,
	    VK_FALSE);

std::vector<VkDynamicState> dynamic_state_enables = {
	VK_DYNAMIC_STATE_VIEWPORT,
	VK_DYNAMIC_STATE_SCISSOR,
	VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT,
	VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT,
	VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT,
	VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT,
};

VkPipelineDynamicStateCreateInfo dynamic_state =
	vkb::initializers::pipeline_dynamic_state_create_info(
	    dynamic_state_enables.data(),
	    static_cast<uint32_t>(dynamic_state_enables.size()),
	    0);

VkGraphicsPipelineCreateInfo graphics_create{VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO};
graphics_create.pInputAssemblyState = &input_assembly_state;
graphics_create.pDynamicState       = &dynamic_state;
...

VK_CHECK(vkCreateGraphicsPipelines(get_device().get_handle(), pipeline_cache, 1, &graphics_create, VK_NULL_HANDLE, &pipeline.baseline));
----

有了 `VK_EXT_extended_dynamic_state2`，我们就可以在对应的每次绘制调用之前改变这些参数：

[,C++]
----
VK_CHECK(vkBeginCommandBuffer(draw_cmd_buffer, &command_begin));

...
/* 绑定 baseline 管线与描述符集 */
vkCmdBindDescriptorSets(draw_cmd_buffer,
		                VK_PIPELINE_BIND_POINT_GRAPHICS,
		                pipeline_layouts.baseline,
		                0,
		                1,
		                &descriptor_sets.baseline,
		                0,
		                nullptr);
vkCmdBindPipeline(draw_cmd_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.baseline);

/* 将拓扑设置为三角形列表，并关闭图元重启 */
vkCmdSetPrimitiveTopologyEXT(draw_cmd_buffer, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST);
vkCmdSetPrimitiveRestartEnableEXT(draw_cmd_buffer, VK_FALSE);

/* 绘制 baseline 场景中的对象（配合光栅化丢弃与深度偏移开关） */
draw_from_scene(draw_cmd_buffer, scene_elements_baseline);

/* 切换拓扑为三角形条带，并启用图元重启 */
vkCmdSetPrimitiveTopologyEXT(draw_cmd_buffer, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP);
vkCmdSetPrimitiveRestartEnableEXT(draw_cmd_buffer, VK_TRUE);

/* 绘制使用图元重启功能的模型 */
draw_created_model(draw_cmd_buffer);

/* 绑定曲面细分用的管线与描述符集 */
vkCmdBindDescriptorSets(draw_cmd_buffer,
		                VK_PIPELINE_BIND_POINT_GRAPHICS,
		                pipeline_layouts.tesselation,
		                0,
		                1,
		                &descriptor_sets.tesselation,
		                0,
		                nullptr);
vkCmdBindPipeline(draw_cmd_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.tesselation);

/* 将拓扑切换为 patch list，并设置曲面细分控制点数量 */
vkCmdSetPrimitiveTopologyEXT(draw_cmd_buffer, VK_PRIMITIVE_TOPOLOGY_PATCH_LIST);
vkCmdSetPatchControlPointsEXT(draw_cmd_buffer, patch_control_points_triangle);

/* 绘制启用曲面细分功能的场景对象 */
draw_from_scene(draw_cmd_buffer, scene_elements_tess);

/* 绑定背景绘制管线与描述符集 */
vkCmdBindDescriptorSets(draw_cmd_buffer,
		                VK_PIPELINE_BIND_POINT_GRAPHICS,
		                pipeline_layouts.background,
		                0,
		                1,
		                &descriptor_sets.background,
		                0,
		                nullptr);
vkCmdBindPipeline(draw_cmd_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline.background);

/* 将拓扑切回三角形列表 */
vkCmdSetPrimitiveTopologyEXT(draw_cmd_buffer, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST);

/* 绘制背景 */
draw_model(background_model, draw_cmd_buffer);
...

VK_CHECK(vkEndCommandBuffer(draw_cmd_buffer));
----

关于“深度偏移”动态状态的使用，见 `draw_from_scene` 函数。对于场景中的每个元素（Geosphere 例外），会根据 GUI 设置启用/关闭深度偏移与光栅化丢弃；函数末尾会重置（设为 VK_FALSE）：

[,C++]
----
void ExtendedDynamicState2::draw_from_scene(VkCommandBuffer command_buffer, std::vector<SceneNode> const &scene_node)
{
	for (int i = 0; i < scene_node.size(); ++i)
	{
		if (scene_node[i].name != "Geosphere")
		{
			vkCmdSetDepthBiasEnableEXT(command_buffer, gui_settings.objects[i].depth_bias);
			vkCmdSetRasterizerDiscardEnableEXT(command_buffer, gui_settings.objects[i].rasterizer_discard);
		}

		...

		vkCmdDrawIndexed(command_buffer, scene_node[i].sub_mesh->vertex_indices, 1, 0, 0, 0);
	}

	vkCmdSetDepthBiasEnableEXT(command_buffer, VK_FALSE);
	vkCmdSetRasterizerDiscardEnableEXT(command_buffer, VK_FALSE);
}
----

== 启用扩展（Enabling the Extension）

“扩展动态状态 2”API 需要 Vulkan 1.0 及相应的头文件/SDK。该扩展已 https://registry.khronos.org/vulkan/specs/latest/man/html/VK_EXT_extended_dynamic_state2.html#_promotion_to_vulkan_1_3[部分] 合入 Vulkan 1.3。

设备扩展名为 `VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME`。同时需要启用实例扩展 `VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME`。

[,C++]
----
add_instance_extension(VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME);
add_device_extension(VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME);
----

如果在传给 vkGetPhysicalDeviceFeatures2 的 `VkPhysicalDeviceFeatures2` 的 pNext 链中包含 https://registry.khronos.org/vulkan/specs/latest/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html[`VkPhysicalDeviceExtendedDynamicState2FeaturesEXT`] 结构体，则其中会被填充以指示各对应特性的支持情况。该结构体也可用于 `VkDeviceCreateInfo` 的 pNext 链，以选择性启用这些特性。
