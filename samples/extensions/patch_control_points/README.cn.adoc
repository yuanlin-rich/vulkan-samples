////
- Copyright (c) 2023-2025, Mobica Limited
-
- SPDX-License-Identifier: Apache-2.0
-
- Licensed under the Apache License, Version 2.0 the "License";
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
-
////
= 曲面细分控制点（Patch control point）

ifdef::site-gen-antora[]
TIP: 本示例源码位于 https://github.com/KhronosGroup/Vulkan-Samples/tree/main/samples/extensions/patch_control_points[Khronos Vulkan Samples GitHub 仓库]。
endif::[]

image::./images/patch_control_point_screenshot.png[Sample]

== 概览

`VK_EXT_extended_dynamic_state2` 扩展允许在不创建多条管线的情况下，动态调整“曲面细分控制点（patch control points）”。扩展将该参数从“管线创建时的静态描述”改为“每次绘制前通过函数设置”。

== 静态 vs 动态设置对比

|===
| 静态/非动态 | Dynamic State 2

| dynamic_state = {VK_DYNAMIC_STATE_VIEWPORT, + VK_DYNAMIC_STATE_SCISSOR}
| dynamic_state = {VK_DYNAMIC_STATE_VIEWPORT, + VK_DYNAMIC_STATE_SCISSOR, + VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT}

| 通过 `VkPipelineTessellationStateCreateInfo::patchControlPoints` 在管线创建时设置
| 在绘制前调用 `vkCmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints)` 动态设置
|===

== 管线

静态方式需在管线创建时给定控制点数量：

[,C++]
----
VkPipelineInputAssemblyStateCreateInfo input_assembly_state = vkb::initializers::pipeline_input_assembly_state_create_info(VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, 0, VK_FALSE);
VkPipelineTessellationStateCreateInfo tessellation_state   = vkb::initializers::pipeline_tessellation_state_create_info(3);
std::vector<VkDynamicState> dynamic_state_enables          = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR };
VkPipelineDynamicStateCreateInfo dynamic_state             = vkb::initializers::pipeline_dynamic_state_create_info(dynamic_state_enables.data(), dynamic_state_enables.size(), 0);
VkGraphicsPipelineCreateInfo graphics_create{VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO};
graphics_create.pInputAssemblyState = &input_assembly_state;
graphics_create.pDynamicState       = &dynamic_state;
graphics_create.pTessellationState  = &tessellation_state;
----

动态方式则在管线中启用 `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST` 与 `VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT`，在绘制前调用 `vkCmdSetPatchControlPointsEXT`：

[,C++]
----
std::vector<VkDynamicState> dynamic_state_enables = { VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR, VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT };
VkPipelineDynamicStateCreateInfo dynamic_state = vkb::initializers::pipeline_dynamic_state_create_info(dynamic_state_enables.data(), dynamic_state_enables.size(), 0);
...
VkGraphicsPipelineCreateInfo graphics_create{VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO};
graphics_create.pInputAssemblyState = &input_assembly_state;
graphics_create.pDynamicState       = &dynamic_state;
----

== 动态设置示例

[,C++]
----
vkCmdBindDescriptorSets(..., pipeline_layouts.dynamically_tessellation, ...);
vkCmdBindPipeline(..., pipeline.dynamically_tessellation);

// 设置控制点数量
vkCmdSetPatchControlPointsEXT(draw_cmd_buffer, patch_control_points_triangle);

// 绘制
draw_model(model, draw_cmd_buffer);
----

== 启用扩展

该 API 需要 Vulkan 1.0 与相应头/SDK，已部分合入 Vulkan 1.3。设备扩展为 `VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME`，并需启用实例扩展 `VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME`。可通过 `VkPhysicalDeviceExtendedDynamicState2FeaturesEXT` 与 `VkPhysicalDeviceExtendedDynamicStateFeaturesEXT` 查询与启用特性。